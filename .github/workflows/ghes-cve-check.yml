name: Check GHES Vulnerabilities

on: 
  workflow_dispatch: 
    inputs: 
      version: 
        description: 'GHES Version'
        required: true
      cves: 
        description: 'CVEs to check'
        required: true

jobs: 
  check_vulnerabilities: 
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Download Metadata
      run: curl -L -o dependencies.tar.gz https://github-enterprise.s3.amazonaws.com/metadata/${{ inputs.version }}/dependencies-${{ inputs.version }}-kvm.tar.gz

    - name: Extract Tarball
      run: tar -xzf dependencies.tar.gz

    - name: Parse and Check CVEs
      run: |
        python3 - << 'EOF'
        import os
        import re
        import requests
        import json

        DEBUG = os.environ.get('DEBUG', 'false').lower() == 'true'

        def debug_print(*args):
            if DEBUG:
                print(*args)

        def extract_name_version(content):
            name = None
            version = None
            name_match = re.search(r'^name:\s*(.+)', content, re.MULTILINE)
            version_match = re.search(r'^version:\s*(.+)', content, re.MULTILINE)
            if name_match:
                name = name_match.group(1).strip()
            if version_match:
                version = version_match.group(1).strip()
            debug_print(f"Extracted name: {name}, version: {version}")
            return name, version

        def get_advisory_by_cve(cve):
            query = """
            query($cveId:String!) {
              securityAdvisories(first: 1, identifier: {type: CVE, value: $cveId}) {
                nodes {
                  identifiers {
                    type
                    value
                  }
                  vulnerabilities(first: 5) {
                    nodes {
                      package {
                        name
                      }
                      vulnerableVersionRange
                    }
                  }
                }
              }
            }
            """
            variables = {
                "cveId": cve
            }
            headers = {
                "Authorization": f"Bearer {os.getenv('GITHUB_TOKEN')}"
            }
            debug_print(f"Sending GraphQL request for CVE {cve}")
            response = requests.post(
                'https://api.github.com/graphql',
                json={'query': query, 'variables': variables},
                headers=headers
            )
            if response.status_code == 200:
                result = response.json()
                if 'errors' in result or not result['data']['securityAdvisories']['nodes']:
                    debug_print(f"No advisories found in GitHub for CVE {cve}, using Ubuntu URL.")
                    return get_ubuntu_advisory_by_cve(cve), "Ubuntu"
                debug_print(f"Advisories for CVE {cve} received from GitHub:", json.dumps(result, indent=2))
                return result, "GitHub"
            else:
                raise Exception(f"Query failed with status code {response.status_code}: {response.text}")

        def get_ubuntu_advisory_by_cve(cve):
            url = f"https://ubuntu.com/security/{cve}"
            debug_print(f"Constructed URL: {url}")
            return url

        def is_vulnerable(package_name, package_version, advisory_data):
            for node in advisory_data.get('data', {}).get('securityAdvisories', {}).get('nodes', []):
                for vulnerability in node.get('vulnerabilities', {}).get('nodes', []):
                    if package_name == vulnerability['package']['name']:
                        # Implement version comparison logic here
                        debug_print(f"Package {package_name} is vulnerable. Affected range: {vulnerability['vulnerableVersionRange']}")
                        return True, vulnerability['vulnerableVersionRange']
            return False, None

        def generate_report(dependencies, cves):
            report = []
            report.append(f"Vulnerability Report for GHES v.{ghes_version}")
            report.append("======================================")
            report.append("")
            for cve in cves:
                report.append(f"CVE: {cve}")
                advisory_data, source = get_advisory_by_cve(cve)
                report.append(f"Source: {source}")
                if source == "Ubuntu":
                    report.append(f"Vulnerability undetermined")
                    report.append(f"Please check the Ubuntu advisory page: {advisory_data}")
                else:
                    affected_packages = []
                    for package_name, package_version in dependencies.items():
                        vulnerable, version_range = is_vulnerable(package_name, package_version, advisory_data)
                        if vulnerable:
                            affected_packages.append(f"WARNING {package_name} {package_version} is vulnerable (Affected range: {version_range})")
                    if affected_packages:
                        report.extend(affected_packages)
                    else:
                        report.append("No vulnerabilities found for the current GHES version.")
                report.append("")
            report.append("")    
            report.append("Note: If a package was marked vulnerable, but the version is good, there might be multiple installations!")
            return "\n".join(report)

        def save_report(report, filename="vulnerability_report.txt"):
            debug_print("Saving report to", filename)
            with open(filename, 'w') as file:
                file.write(report)

        ghes_version = os.environ.get('VERSION')
        cves = os.environ.get('CVES').split(',')
        dependencies = {}

        for root, dirs, files in os.walk('.'):
            for file in files:
                if file.endswith('.yml') or file.endswith('.txt'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r') as stream:
                            content = stream.read()
                            name, version = extract_name_version(content)
                            if name and version:
                                dependencies[name] = version
                    except Exception as e:
                        debug_print(f"Warning: An unexpected error occurred while processing {file_path}: {e}")

        report = generate_report(dependencies, cves)
        save_report(report)
        EOF
      env:
        VERSION: ${{ inputs.version }}
        CVES: ${{ inputs.cves }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        DEBUG: 'false' # Enable debugging output

    - name: Upload Report
      uses: actions/upload-artifact@v4
      with:
        name: vulnerability-report
        path: vulnerability_report.txt
