name: Check GHES Vulnerabilities

on: 
  workflow_dispatch: 
    inputs: 
      version: 
        description: 'GHES Version'
        required: true
      cves: 
        description: 'CVEs to check'
        required: true

jobs: 
  check_vulnerabilities: 
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download Metadata
      run: curl -L -o dependencies.tar.gz https://github-enterprise.s3.amazonaws.com/metadata/${{ inputs.version }}/dependencies-${{ inputs.version }}-kvm.tar.gz

    - name: Extract Tarball
      run: tar -xzf dependencies.tar.gz

    - name: Parse and Check CVEs
      run: |
        python3 - << 'EOF'
        import os
        import re
        import requests
        import json

        DEBUG = os.environ.get('DEBUG', 'false').lower() == 'true'

        def debug_print(*args):
            if DEBUG:
                print(*args)

        def extract_name_version(content):
            name = None
            version = None
            name_match = re.search(r'^name:\s*(.+)', content, re.MULTILINE)
            version_match = re.search(r'^version:\s*(.+)', content, re.MULTILINE)
            if name_match:
                name = name_match.group(1).strip()
            if version_match:
                version = version_match.group(1).strip()
            debug_print(f"Extracted name: {name}, version: {version}")
            return name, version

        def get_advisory_by_cve(cve):
            query = """
            query($cveId:String!) {
              securityAdvisories(first: 1, identifier: {type: CVE, value: $cveId}) {
                nodes {
                  identifiers {
                    type
                    value
                  }
                  vulnerabilities(first: 5) {
                    nodes {
                      package {
                        name
                      }
                      vulnerableVersionRange
                    }
                  }
                }
              }
            }
            """
            variables = {
                "cveId": cve
            }
            headers = {
                "Authorization": f"Bearer {os.getenv('GITHUB_TOKEN')}"
            }
            debug_print(f"Sending GraphQL request for CVE {cve}")
            response = requests.post(
                'https://api.github.com/graphql',
                json={'query': query, 'variables': variables},
                headers=headers
            )
            if response.status_code == 200:
                result = response.json()
                if 'errors' in result or not result['data']['securityAdvisories']['nodes']:
                    debug_print(f"No or unreviewed advisories found in GitHub for CVE {cve}, querying cve.org.")
                    return get_cve_org_advisory_by_cve(cve), "cve.org"
                debug_print(f"Advisories for CVE {cve} received from GitHub:", json.dumps(result, indent=2))
                return result, "GitHub"
            else:
                raise Exception(f"Query failed with status code {response.status_code}: {response.text}")

        def get_cve_org_advisory_by_cve(cve):
            url = f"https://cveawg.mitre.org/api/cve/{cve}"
            debug_print(f"Fetching CVE data from cve.org API for {cve}")
            try:
                response = requests.get(url)
                debug_print(f"Response Status Code: {response.status_code}")

                if response.status_code == 200:
                    cve_data = response.json()
                    debug_print(f"CVE data received: {json.dumps(cve_data, indent=2)}")
                    return cve_data
                elif response.status_code == 404:
                    debug_print(f"CVE {cve} not found in cve.org database.")
                    return None
                else:
                    debug_print(f"Failed to fetch data: {response.text}")
                    raise Exception(f"Failed to fetch CVE data from cve.org with status code {response.status_code}: {response.text}")
            except requests.exceptions.RequestException as e:
                debug_print(f"RequestException occurred: {e}")
                raise Exception(f"An error occurred while fetching CVE data: {e}")

        def is_vulnerable(package_name, package_version, advisory_data, source):
            if source == "GitHub":
                for node in advisory_data.get('data', {}).get('securityAdvisories', {}).get('nodes', []):
                    for vulnerability in node.get('vulnerabilities', {}).get('nodes', []):
                        if package_name == vulnerability['package']['name']:
                            # Implement version comparison logic here
                            debug_print(f"Package {package_name} is vulnerable. Affected range: {vulnerability['vulnerableVersionRange']}")
                            return True, vulnerability['vulnerableVersionRange']
            elif source == "cve.org":
                if advisory_data:
                    descriptions = advisory_data.get('containers', {}).get('cna', {}).get('descriptions', [])
                    fixed_versions = []
                    for desc in descriptions:
                        description_text = desc.get('value', '')
                        # Updated regex to capture versions including digits, dots, commas, spaces, and 'and'
                        matches = re.findall(r'fixed in versions? ([\d\.\s, and]+)', description_text, re.IGNORECASE)
                        if matches:
                            for match in matches:
                                # Split versions by commas or 'and'
                                versions = re.split(r',\s*|\s+and\s+', match.strip())
                                # Clean up versions by stripping whitespace
                                versions = [v.strip() for v in versions if v.strip()]
                                fixed_versions.extend(versions)
                    if fixed_versions:
                        debug_print(f"Found fixed versions: {fixed_versions}")
                        return True, fixed_versions
                    else:
                        debug_print("No fixed versions found in CVE descriptions.")
                        return False, None
            return False, None

        def generate_report(dependencies, cves):
            report = []
            report.append(f"Vulnerability Report for GHES v.{ghes_version}")
            report.append("======================================")
            report.append("")
            for cve in cves:
                report.append(f"CVE: {cve}")
                advisory_data, source = get_advisory_by_cve(cve)
                report.append(f"Source: {source}")
                references = [
                    f"https://www.cve.org/CVERecord?id={cve}",
                    f"https://github.com/advisories?query={cve}"
                ]
                if source == "GitHub":
                    affected_packages = []
                    for package_name, package_version in dependencies.items():
                        vulnerable, version_range = is_vulnerable(package_name, package_version, advisory_data, source)
                        if vulnerable:
                            affected_packages.append(f"WARNING: {package_name} {package_version} is vulnerable (Affected range: {version_range})")
                    if affected_packages:
                        report.extend(affected_packages)
                    else:
                        report.append("No vulnerabilities found for the scanned GHES version.")
                elif source == "cve.org":
                    vulnerable, fixed_versions = is_vulnerable(None, None, advisory_data, source)
                    if vulnerable and fixed_versions:
                        report.append(f"Fixed in versions: {', '.join(fixed_versions)}.")
                    else:
                        report.append("Details undetermined. Update to latest patch release.")
                report.append("References:")
                report.extend(references)
                report.append("")
            report.append("")
            report.append("Note: For CVEs sourced from cve.org, please review the details manually as package information may be incomplete.")
            report.append("      Packages marked vulnerable when their version looks good might be due to being installed in multiple locations.")
            return "\n".join(report)

        def save_report(report, filename="vulnerability_report.txt"):
            debug_print("Saving report to", filename)
            with open(filename, 'w') as file:
                file.write(report)

        ghes_version = os.environ.get('VERSION')
        cves = os.environ.get('CVES').split(',')
        dependencies = {}

        for root, dirs, files in os.walk('.'):
            for file in files:
                if file.endswith('.yml') or file.endswith('.txt'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r') as stream:
                            content = stream.read()
                            name, version = extract_name_version(content)
                            if name and version:
                                dependencies[name] = version
                    except Exception as e:
                        debug_print(f"Warning: An unexpected error occurred while processing {file_path}: {e}")

        report = generate_report(dependencies, cves)
        save_report(report)
        EOF
      env:
        VERSION: ${{ inputs.version }}
        CVES: ${{ inputs.cves }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        DEBUG: 'true' # Enable debugging output

    - name: Upload Report
      uses: actions/upload-artifact@v4
      with:
        name: vulnerability-report
        path: vulnerability_report.txt
